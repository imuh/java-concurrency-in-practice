### 1.4 Потоки повсюду
Даже если ваша программа никогда не порождает потоков явным способом, их могут создавать фреймворки, которые вы используете, и код, вызываемый из этих потоков обязан быть потокобезопасным. Это обстоятельство может значительно усложнить архитектуру и разработку программы в связи с тем, что разработка потокобезопасных классов требует большего расчета и анализа, чем не-потокобезопасных.

Каждое java-приложение использует потоки. Когда запускается JVM, она создает потоки для обслуживания своей собственной работы (сборка мусора, финализация(finalization)) и поток для запуска метода main. Такие GUI-фреймворки, как AWT (Abstract Window Toolkit) и Swing, создают потоки для управления событиями графического интерфейса. Timer создает потоки для исполнения отложенных задач. Компонентные фреймворки, например, сервлеты и RMI создают пулы потоков и исполняют методы компонентов в них.

Если вы используете данные библиотеки - как многие разработчики - вы должны быть знакомы с многопоточностью и потокобезопасностью, поскольку эти фреймворки создают потоки и из них вызывают ваши компоненты. Было бы здорово верить, что многопоточность - это "необязательная" или "продвинутая" возможность языка, но в реальности почти все Java приложения многопоточны и эти фреймворки не изолируют вас от необходимости грамотно координировать доступ к состоянию приложения.

Когда многопоточность в приложение вносится фреймворком, в большинстве случаев нельзя оставить ее на попечение самого фреймворка потому, что он, по своей сути, обращается к компонентам приложения, имеющим доступ ко внутреннему состоянию приложения. Требование потокобезопасности распространяется не только на эти компоненты приложения, но также на весь код, взаимодействующий с изменяемым состоянием приложения. Таким образом, требование потокобезопасности *заразительно*. 

> Фреймворки приносят многопоточность в приложение, вызывая и исполняя компоненты приложения в своих потоках. Компоненты имеют доступ ко внутреннему состоянию приложения, что означает, что весь код, взаимодействующий с этим состоянием должен быть потокобезопасным. 

Все библиотеки, описанные ниже, являются причиной того, что код приложения вызывается из потоков, управляемых не приложением. Хотя потребность в потокобезопасности может возникнуть при использовании этих библиотек, она редко ими ограничивается, напротив, она пронизывает все приложение.

Timer. Timer это удобный механизм для планировки отложенного исполнения задач, однократного или периодического. Использование класса Timer способно усложнить иную последовательно исполняющуюся программу, поскольку его задания (TimerTask) исполняются в потоках, которыми управляет Timer, не приложение. Если данные, к которым обращается задание, также используются другими потоками приложения, то и задание, и все классы, обращающиеся к этим данным, должны работать с ними потокобезопасно. Часто, наиболее простой способ достичь этого - это гарантировать, что объекты, к которым имеет доступ задание, сами являются потокобезопасными, таким образом инкапсулировать потокобезопасность внутри объектов общего доступа.

Сервлеты и JSP. Фреймворк сервлетов разработан для манипуляции над  инфраструктурой  развертывания веб-приложения и обработки запросов от удаленных  HTTP клиентов. Запросы, поступающие на сервер во время обработки, вероятно, проходят через цепочку фильтров, поступая в подходящий сервлет или JSP. Каждый сервлет представляет компонент логики приложения, и, на больших сайтах, может потребоваться одновременная обработка одним и тем же сервлетом множества запросов пользователей. Спецификация сервлетов требует, чтобы сервлет был готов к вызову из множества потоков одновременно. Другими словами, сервлеты должны быть потокобезопасными.

Даже если вы можете гарантировать, что конкретный сервлет будет вызван одновременно только из одного потока, вам все равно придется быть внимательным к потокобезопасности при сборки веб-приложения. Сервлеты часто обращаются к общей информации, которая может быть доступна другим сервлетам, такой как объекты контекста приложения (которые хранятся в ServletContext) или объекты контекста сессии (хранятся в HttpSession, своей для каждого клиента). Когда сервлет обращается к объектам, общим для всех сервлетов или запросов, он обязан организовать корректный доступ к этим объектам, так как вероятен множественный доступ к ним одновременно из разных запросов, исполняющихся в различных потоках. И сервлеты, и JSP, так же как и фильтры сервлетов, и объекты, хранимые в контейнерах контекста, таких как ServletContext и HttpSession, просто обязаны быть потокобезопасными.

Удаленный вызов метода (RMI). RMI позволяет вам вызывать методы объектов, запущенных в другой JVM. Когда вы вызываете удаленный метод с RMI, аргументы метода упаковываются (маршализуются) в поток байт и отправляются по сети к удаленной JVM, где они распаковываются (демарашлихуются) и передаются в удаленный метод.

Когда RMI код вызывает ваш удаленный объект, в каком потоке должен обрабатываться вызов? Вы не знаете, но это точно не поток, который вы создали - ваш объект вызывается из потока, управляемого RMI. Как много потоков создает RMI? Может ли один и тот же метод одного и того же удаленного объекта вызываться одновременно из нескольких RMI?[1]

[1] Ответ: да, но не все так просто понятно из Javadoc - вы должны прочесть спецификацию RMI.

Удаленный объект должен противостоять двум угрозам потокобезопасности: корректно скоординированному доступу к состоянию, которое может быть общим для других объектов, и корректно скоординированному доступу к состоянию самого удаленного объекта (так как один и тот же объект может быть вызван одновременно из множества потоков). Как и сервлеты, RMI объектов должен быть подготовлен к множеству одновременных вызовов и обязан обеспечить их собственную потокобезопасность.

Swing и AWT. GUI - приложения по своей сути асинхронны. Пользователи могут выбрать пункт меню или нажать кнопку в любой момент времени, и они ожидают, что приложение сразу ответит, даже если оно находится в посреди исполнения какой-либо другой задачи. Swing и AWT обходят эту проблему создавая отдельные потоки для обработки событий, инициированных пользователем, и обновления графического представления пользователю.

Компоненты Swing, такие как JTable, не потокобезопасны. Вместо этого, программы Swing достигают потокобезопасности ограничивая доступ к компонентам GUI потоком событий. Если приложение хочет воздействовать на GUI извне потока событий, оно обязано вызвать код, манипулирующий GUI, в потоке событий.

Когда пользователь производит UI действие, в потоке событий вызывается обработчик события для осуществления какой-либо запрошенной пользователем операции. Если обработчик должен обратиться к состоянию приложения, которое также доступно из других потоков (например, документ, над которым идет правка), то обработчик события, наряду с любым другим кодом, обращающимся к этому состоянию, должен делать это потокобезопасно.