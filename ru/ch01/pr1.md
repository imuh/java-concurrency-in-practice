### 1.1 Краткая история многопоточности

В древнем прошлом компьютеры не имели операционных систем; они исполняли одну программу с начала до конца, и эта программа имела полный доступ к ресурсам вычислительной машины. Проблема была не только в том, что было трудно писать программы, которые запускались на "голом" железе, но и в том, что исполнение одновременно только одной программы было неэффективным исопльзованием дорогих и дефицитных вычислительных ресурсов.

Операционные системы эволюционировали и позволили исполнять одновременно более чем одну программы, которые запускались в отдельных *процессах*: изолированные, независимые друг от друга исполняемые программы для которых операционная система выделяла ресуры, такие как память, обработчики файлов и учетные данные безопасности. Если это требовалось, процессы могли взаимодействовать друг с другом с помощью различных крупномодульных механизмов взаимодействия: сокетов, обработчиков сигналов, разделяемой памяти, семафоров и файлов.

Несколько мотивирующих факторов привели к разработке операционных систем, которые поддерживали одновременное исполнение несколько программ:

**Утилизация ресурсов**. Программам в некоторых случаях приходится ожидать выполнения внешних операций, таких как ввод или вывод, в течение которых они не выполняют полезной работы. Намного эффективнее использовать это время для исполнения другой программы.

**Честность**. Несколько пользователей и программ могут иметь равные потребности в ресурсах машины. Предпочтительнее предоставить доступ на более детализированные участки времени, нежели позволять одной программе полностью завершиться, и уже после запускать другую.

**Удобство**. Часто проще и целесообранее написать несколько программ, каждая из которых выполняет одну задачу и координировать их между собой, если это необходимо, вместо написания одной программы, исполняющей все задачи.
