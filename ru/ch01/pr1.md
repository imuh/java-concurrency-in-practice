### 1.1 Краткая история многопоточности

В прошлом компьютеры не имели операционных систем: они исполняли одну программу от начала до конца, и эта программа имела полный доступ к ресурсам вычислительной машины. Проблема заключалась не только в том, что было трудно писать программы, которые запускались на "голом" железе, но и в том, что исполнение одновременно только одной программы было неэффективным использованием дорогих и дефицитных вычислительных ресурсов.

Операционные системы эволюционировали и позволили исполнять одновременно более чем одну программу, которая запускалась в отдельном *процессе*: изолированные, независимые друг от друга исполняемые программы для которых операционная система выделяла ресуры, такие как память, обработчики файлов и учетные данные безопасности. Если это требовалось, процессы могли взаимодействовать друг с другом с помощью различных крупномодульных механизмов взаимодействия: сокетов, обработчиков сигналов, разделяемой памяти, семафоров и файлов.

Несколько мотивирующих факторов привели к разработке операционных систем, которые поддерживали одновременное исполнение несколько программ:

**Утилизация ресурсов**. Программам в некоторых случаях приходится ожидать выполнения внешних операций, таких как ввод или вывод, в течение которых они не выполняют полезной работы. Намного эффективнее использовать это время для исполнения другой программы.

**Честность**. Несколько пользователей и программ могут иметь равные потребности в ресурсах машины. Предпочтительнее предоставлять доступ на более детализированные участки времени, нежели позволять одной программе полностью завершиться, и уже после запускать другую.

**Удобство**. Часто проще и целесообранее написать несколько программ, каждая из которых выполняет одну задачу и координировать их между собой, если это необходимо, вместо написания одной программы, исполняющей все задачи.

В ранних системах с разделяемым временем, каждый процесс представлял из себя виртуальную машину фон Неймана; команды и данные совместно хранились в памяти, команды исполнялись последовательно в соответствии с семантикой машинного языка, и взаимодействие с внешним миром осуществлялось с помощью набора примитивов ввода/вывода. За каждой исполняемой командой следовала четко заданная следующая команда, поток исполнения программы определялся правилами набора команд. Почти все широкоиспользуемые современные языки разработки следуют данной последовательной модели программирования, в которой спецификация языка четко определяет "что следует дальше" после исполнения определенного действия.

Последовательная модель программирования интуитивна и естественна, она моделирует человеческую деятельность: заниматься одной вещью одновременно, в основном последовательно. Встать с кровати, надеть халат, спуститься вниз и заварить чай. Так же как и в языках программирования, каждое из этих человеческих действий - это абстракция для последовательности более детализированных действий: открыть шкаф, выбрать вкусный чай, отмерить некоторое количество в заварник, удостовериться, что необходимое количество воды находится в чайнике, в противном случае - долить воды, поставить чайник на плиту, включить плиту, подождать пока вода закипит и так далее. Последнее действие - подождать пока вода закипит - также имеет некоторую степень *асинхронности*. Пока вода нагревается, у вас есть выбор, что делать в это время - просто ждать или выполнять другие задачи, например готовить тосты (очередная асинхронная задача) или сходить за газетой, держа в голове то, что в скором времени необходимо будет уделить время чайнику.
Производители чайников и тостеров в курсе, что их продукты часто используются в асинхронном режиме, поэтому звуковой сигнал возвещает об окончании выполнения их задачи. Умение находить золотую середину между последовательным исполнением и асинхронностью - отиличительная черта успешных людей, что справедливо и для программ.

Те же факторы (утилизация ресурсов, честность и удобство) явились толчком создания процессов, так же и способствовали созданию *потоков*(threads|нитей). Треды позволяют нескольким потокам управления программы сосуществовать в рамках процессов. Они разделяют ресурсы процесса, такие как память, обработчики файлов, но в то же время каждый поток имеет собственный программный счетчик, стэк и локальные переменные. Потоки обеспечивают естественную декомпозицию для эксплутации аппаратного параллелизма мультипроцессорных систем; несколько потоков одной программы могут исполняться одновременно на нескольких процессорах.

Потоки иногда называют *легковесными процессами*, и большинство современных операционных систем обрабатывают потоки, а не процессы, как базовую единицу исполнения. В отсутствии явной координации, потоки исполняются одновременно и асинхронно по отношению друг к другу. В силу того что потоки разделяют адресное пространство своих процессов, все потоки внутри одного процесса имеют доступ к тем же переменным и существующим объектам в той же куче. Это способствует более гранулярному разделению данных в сравнении с механизмами межпроцессорного взаимодействия. Но в случае отсутствия явной синхронизации в доступе к разделяемым данных, поток может модифицировать переменные, в то время как другой поток не закончил операции по использованию этих переменных, что может привести к непредсказуемым последствиям.
