###2 Потокобезопасность
Удивительно, но многопоточное программирование (concurrent programming) о потоках или блокировках не больше, чем гражданское строительство о заклепках и двутавровых балках. Конечно, строительство мостов, которые не рушатся требует грамотного применения большого числа заклепок и балок, так же как и построение многопоточных программ требует грамотного использования потоков и блокировок. Но все перечисленное - всего лишь механизмы для достижения конечной цели. Написание потокобезопасного кода, в первую очередь, - об управлении доступом к общедоступным, изменяемым объектам. 

Неофициально, состояние объекта - это данные, хранимые в переменных, таких как поля объекта или статические поля. Состояние объекта может включать в себя поля других  зависимых объектов; состояние HashMap частично хранится в самом объекте HashMap, но также во множестве объектов Map.Entry. Состояние объекта включает в себя любые данные, которые могут повлиять на его поведение, наблюдаемое извне.

Под общедоступной мы понимаем (подразумеваем) переменную, доступ к которой может быть осуществлен из нескольких потоков, под изменяемостью мы понимаем, что ее значение может измениться со временем. Мы можем говорить о потокобезопасности, как о коде (?),  но что мы действительно пытаемся сделать - это защитить данные от неконтролируемого конкурентного доступа.

Потребность в потокобезопасности для объекта зависит от того, будет ли он доступен из нескольких потоков. Для этого важно как объект используется в программе, а не что он делает. Реализация потокобезопасности объекта требует использования синхронизации для координирования доступа к его изменяемому состоянию; несоблюдение этого требования может привести к повреждению данных и другим нежелательным последствиям.

Всякий раз когда больше одного потока обращаются к переменной состояния, и один из них может ее изменять, все они должны координировать свой доступ к данной переменной, используя синхронизацию. Основной механизм для синхронизации в Java  - ключевое слово synchronized, которое предоставляет исключительную блокировку, однако термин "синхронизация" также включает в себя использование volatile переменных, явных блокировок и атомарных переменных.

Вы должны избегать соблазна мысли о том, что есть "специальные" ситуации, в которых данное правило неприменимо. Программа, пренебрегающая нужной (?) синхронизацией, может выглядеть рабочей, проходить все тесты и успешно исполняться на протяжении лет, но оставаться сломанной и может подвести в любой момент.

> Если несколько потоков одновременно обращаются к одной и той же переменной состояния без соответствующей синхронизации, ваша программа неисправна. Существует 3 пути починить ее:
> 
* Не делите переменную состояния между потоками;
* Сделайте переменную состояния неизменяймой; или
* Используйте синхронизацию всякий раз, когда происходит обращение к переменной.

Если у вас еще нет продуманного конкурентного доступа в дизайне вашего класса, некоторые из этих подходов могут нуждаться в существенном изменении дизайна, поэтому исправление проблемы может оказаться не такой тривиальной задачей, как может показаться. Гораздо проще спроектировать класс потокобезопасным сразу, чем переделывать его позже.

В большой программе, понять имеется ли доступ к конкретной переменной из множества потоков, может быть сложно. К счастью, те же объектно-ориентированные приемы, что помогает вам писать грамотно организованные, поддерживаемые классы - такие как инкапсуляция и сокрытие данные, также могут помочь вам создавать потокобезопасные классы. Чем меньше кода имеет доступ к конкретной переменной, тем проще гарантировать, что весь он использует должную синхронизацию, и проще определить условия, согласно которым будет осуществлен доступ к ней. Язык Java не заставляет вас инкапсулировать состояние - вполне приемлимо хранить состояние в публично доступных (более того, хоть в статических) полях, или опубликовать ссылку на другой внутренний объект - но чем лучше инкапсулировано состояние, тем легче сделать вашу программу потокобезопасной и проще ее поддерживать в таком состоянии.

> При разработке потокобезопасных классов, хорошие техники, на которые следует ориентироваться - инкапсуляция, неизменность, и четкое определение инвариантов.

Временами хорошие объектно-ориентированные техники сталкиваются со странностями требований реального мира; в таких случаях важно найти компромисс между хорошим дизайном и производительностью или между дизайном и обратной совместимостью с (legacy) кодом. Иногда абстракция и инкапсуляция негативно влияют на производительность - далеко не так часто, как многие разработчики думают - однако всегда верной практикой будет сначала написать корректный код, а затем ускорять его работу. Даже тогда, производите оптимизацию только если ваши измерения производительности и требования говорят вам о том, что вы должны ее сделать, и только если эти измерения говорят о том, что ваша оптимизация внесет какую-либо разницу при реальных условиях работы. [1]

[1] В многопоточном коде следует придерживаться этой практики больше, чем обычно, потому что дефекты многопоточного приложения тяжелее воспроизвести и отладить. Выгода от небольшого прироста производительности, полученного написанием неочевидного кода, нивелируются риском того, что программа в любой момент может подвести.

Если вы решили, что вам просто необходимо нарушить инкапсуляцию, не все потеряно. Все еще можно сделать вашу программу потокобезопасной, просто сделать это будет несколько сложнее. Более того, потокобезопасность вашей программы будет более хрупкой, повышая не только стоимость и риски разработки, но и стоимость и риски поддержки. Глава 4 характеризует условия, под которыми можно безопасно ослабить инкапсуляцию переменных состояния.
До сих пор мы использовали термины "потокобезопасный класс" и "потокобезопасная программа" как практически взаимозаменяемые. Является ли потокобезопасной программа, состоящая целиком из потокобезопасных классов? Не обязательно - программа, которая состоит целиком из потокобезопасных классов может не быть потокобезопасной, и потокобезопасная программа может содержать классы, не являющиеся потокобезопасными. Вопросы касательно композиции потокобезопасных классов также объяснены в Главе 4. В любом случае, концепция потокобезопасных классов имеет смысл только если класс инкапсулирует свое собственное состояние. Хотя  потокобезопасность - это термин, применяемый к коду, она про состояние и может быть применена только к телу кода, инкапсулирующего свое состояние, которое может быть как объектом, так и всей программой.